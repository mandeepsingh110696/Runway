---
description: React performance best practices from Vercel Engineering
globs: "**/*.tsx"
alwaysApply: false
---

# React Performance Best Practices

## Eliminating Waterfalls (CRITICAL)

```typescript
// ❌ BAD: Sequential fetches
const user = await fetchUser()
const posts = await fetchPosts()

// ✅ GOOD: Parallel fetches
const [user, posts] = await Promise.all([fetchUser(), fetchPosts()])
```

## Bundle Size

```typescript
// ❌ BAD: Barrel imports
import { Button, Input } from '@/components/ui'

// ✅ GOOD: Direct imports
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
```

## Server Components (Default)

- Use Server Components by default
- Only add `'use client'` when needed (hooks, event handlers, browser APIs)
- Minimize data passed across RSC boundaries

## Re-render Optimization

```typescript
// ❌ BAD: Derived state in effect
const [items, setItems] = useState([])
const [count, setCount] = useState(0)
useEffect(() => setCount(items.length), [items])

// ✅ GOOD: Derive during render
const [items, setItems] = useState([])
const count = items.length
```

## Functional setState

```typescript
// ❌ BAD: Depends on stale state
const addItem = () => setItems([...items, newItem])

// ✅ GOOD: Functional update
const addItem = () => setItems(prev => [...prev, newItem])
```

## Lazy State Initialization

```typescript
// ❌ BAD: Runs on every render
const [data] = useState(expensiveComputation())

// ✅ GOOD: Runs once
const [data] = useState(() => expensiveComputation())
```
