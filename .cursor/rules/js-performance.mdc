---
description: JavaScript performance patterns
globs: "**/*.ts,**/*.tsx"
alwaysApply: false
---

# JavaScript Performance

## Use Map for O(1) Lookups

```typescript
// ❌ BAD: O(n) per lookup
const user = users.find(u => u.id === targetId)

// ✅ GOOD: O(1) lookup
const userById = new Map(users.map(u => [u.id, u]))
const user = userById.get(targetId)
```

## Early Returns

```typescript
// ❌ BAD: Nested conditions
function process(data) {
  if (data) {
    if (data.valid) {
      return doWork(data)
    }
  }
  return null
}

// ✅ GOOD: Early returns
function process(data) {
  if (!data) return null
  if (!data.valid) return null
  return doWork(data)
}
```

## Avoid Layout Thrashing

```typescript
// ❌ BAD: Interleaved reads/writes
element.style.width = '100px'
const width = element.offsetWidth // Forces reflow
element.style.height = '200px'

// ✅ GOOD: Batch writes, then read
element.style.width = '100px'
element.style.height = '200px'
const { width, height } = element.getBoundingClientRect()
```

## Use toSorted() for Immutability

```typescript
// ❌ BAD: Mutates original
const sorted = items.sort((a, b) => a.value - b.value)

// ✅ GOOD: Creates new array
const sorted = items.toSorted((a, b) => a.value - b.value)
```

## Combine Array Iterations

```typescript
// ❌ BAD: Multiple iterations
const filtered = items.filter(x => x.active)
const mapped = filtered.map(x => x.name)

// ✅ GOOD: Single iteration
const result = []
for (const item of items) {
  if (item.active) result.push(item.name)
}
```
